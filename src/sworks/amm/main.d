/** Automatic Makefile Maker.
Version:    0.171(dmd2.085.0)
Date:       2019-Mar-21 15:20:51
Authors:    KUMA
License:    CC0
*/

module sworks.amm.main;

///
enum _VERSION_ = "0.171(dmd2.085.0)";

///
enum header =
    "Automatic Makefile Maker v" ~ _VERSION_ ~ ". Written by KUMA under CC0.";

///
string description()
{
    return _("This is a program that makes a Makefile from source files wirtten in D programmming language.");
}

///
enum how_to_use =
    ">amm [target.exe] [make-style.xml] [option for dmd] [options] rootfile.d";

///
mixin NamedEnum!(
    "bracket",
    "env",
    "exe_ext",
    "obj_ext",
    "lib_ext",
    "gen_deps_command",
    "deps_file",
    "m",
    "root",
    "compile_flag",
    "link_flag",
    "target",
    "dependencies",
    "to_compile",
    "to_link",
    "rc_file",
    "def",
    "ddoc",
    "dd",
    "libs",
    "imp",
    "lib",
    "i",
    "is_dll",
    "is_lib",
    "verbose",
    "q",
    "footer",
    "style_file",
    "v",
    "authors",
    "license",
    "date",
    "remake_command",
    "src",
    "is_vclinker",
    "dll_ext",
    "mak_ext",
    "src_ext",
    "rc_ext",
    "rc",
    "def_ext",
    "ddoc_ext",
    "xml_ext",
    "style",
    ) PredefinedMacrosList;

//==============================================================================
import sworks.base.output;
import sworks.stylexml;
import sworks.base.mo;
import sworks.base.getopt;
import sworks.amm.args_data;
import sworks.amm.ready_data;
import sworks.amm.deps_data;
debug import std.stdio : writeln;

void main(string[] args)
{
    import std.conv: to;
    import std.file: exists, write;
    import std.exception : enforce;
    import std.string : lastIndexOf;
    import std.process: environment;
    import std.file: read;

    alias ML = PredefinedMacrosList;

    _.basePath = "l10n\\amm";
    _.setlocale(environment.get("LANG", "en"));

    StyleParser parser;
    // マクロに初期値を設定
    auto data = default_macros;

    // コマンドライン引数解析
    auto result = data.set_args_data!PredefinedMacrosList(args);

    // ヘルプメッセージの表示
    if (result.helpWanted)
    {
        show_help(result.helpAbout, result.options, data);
        return;
    }

    // -style.xml ファイルの読み込み。
    auto str = data[ML.style].read.to!string;
    logln("success to open ", data[ML.style]);
    parser = new StyleParser(str, data);
    logln("parser is ready");

    // -style.xml ファイルのヘッダだけは読み込んでおく。
    parser.parseHead;
    logln("<head> is parsed successfully");

    // マクロを準備する。
    ready_data!ML(data);
    logln("macros are ready");

    data.logout_macros;

    // 依存関係を解決
    set_deps_data!ML(data);
    logln("dependencies are whole resolved.");

    //########## 準備完了 ##########
    // -style.xml ファイルのボディを処理する。
    logln("parse start.");
    auto makefile_cont = parser.parseBody();
    logln("parse success.");

    enforce(0 < makefile_cont.length, "failed to generate Makefile by " ~
            data[ML.style]);

    // Makefile が既存で、footer が見つかった場合、それ以降は残す。
    auto footer = data[ML.footer];
    if (0 < footer.length && data[ML.m].exists)
    {
        logln("old makefile is detected.");
        auto old_makefile_cont = data[ML.m].read.to!string;
        auto i = old_makefile_cont.lastIndexOf(footer);
        if (0 < i)
        {
            string post_footer = old_makefile_cont[i+footer.length .. $];
            if (0 < post_footer.length)
            {
                logln("post-footers are detected.");
                makefile_cont ~= post_footer;
            }
        }
    }

    // Makefile を出力。
    data[ML.m].write(makefile_cont);
    logln("complete.");
}

////////////////////////////////////////////////////////////////////////////////
private:

// マクロに初期値を設定します。
auto default_macros()
{
    import std.path: pathSeparator;

    alias ML = PredefinedMacrosList;

    auto db = new Macros;

    static @safe @nogc pure nothrow
    auto OS(string win, string nix)
    { version (Windows) return win; else return nix; }

    db[ML.bracket] = new BracketItem(OS("rn", "n"));
    db[ML.env] = "";
    db[ML.exe_ext] = OS(".exe", "");
    db[ML.obj_ext] = OS(".obj", ".o");
    db[ML.lib_ext] = OS(".lib", ".a");
    db[ML.gen_deps_command] = "dmd -c -op -o- -debug";
    db[ML.deps_file] = "tempdeps";
    db[ML.m] = "Makefile";
    db[ML.root] = "";
    db[ML.compile_flag] = "";
    db[ML.link_flag] = "";
    db[ML.target] = "";
    db[ML.dependencies] = "";
    db[ML.to_compile] = "";
    db[ML.to_link] = "";
    db[ML.rc_file] = "";
    db[ML.def] = "";
    db[ML.ddoc] = "";
    db[ML.dd] = "doc";
    db[ML.libs] = "";
    db[ML.imp] = new MacroItem("import", pathSeparator);
    db[ML.lib] = new MacroItem("lib", pathSeparator);
    db[ML.i] = "imp_root ~ ';' ~ root";
    db[ML.is_dll] = "";
    db[ML.is_lib] = "";
    db[ML.verbose] = "";
    db[ML.q] = "";
    db[ML.footer] = "## generated by amm.";
    db[ML.style_file] = "make-style.xml";
    db[ML.v] = "";
    db[ML.authors] = "";
    db[ML.license] = "";
    db[ML.date] = "";
    db[ML.remake_command] = "";
    db[ML.src] = new MacroItem("src", pathSeparator);
    db[ML.is_vclinker] = "";
    db[ML.dll_ext] = OS(".dll", ".so");
    db[ML.mak_ext] = ".mak";
    db[ML.src_ext] = ".d";
    db[ML.rc_ext] = ".rc";
    db[ML.rc] = "";
    db[ML.def_ext] = ".def";
    db[ML.ddoc_ext] = ".ddoc";
    db[ML.xml_ext] = ".xml";
    db[ML.style] = "make-style.xml";

    // 全部あるかチェック
    debug
    {
        foreach (one; __traits(allMembers, ML))
            assert (db.exists(one),
                    _("%s is not found.", one));
    }
    return db;
}

//
string getHelpAboutMacro(string ml)
{
    alias ML = PredefinedMacrosList;

    switch (ml)
    {
    case ML.bracket:
        return _("specify newline characters. `'rn'` => CR+LF. `'n'` => LF. `'r'` => CR.");
    case ML.env:
        return _("This macro exists for backward compatibility.");
    case ML.exe_ext:
        return _("specify a extension of an executable file name.");
    case ML.obj_ext:
        return _("specify a extension of a object file name.");
    case ML.lib_ext:
        return _("specify a extension of a statically linked library file name.");
    case ML.gen_deps_command:
        return _("specify the command that invokes dmd to resolve your project's dependencies.");
    case ML.deps_file:
        return _("specify the file name of the target of `'gen_deps_command'`.");
    case ML.m:
        return _("specify the name of the Makefile.");
    case ML.root:
        return _("specify the file name of root file of your project. When a file that has `'.d'` as its extension is passed as a command line argument, the file name will be set to this macro.");
    case ML.compile_flag:
        return _("specify compile flags for dmd. When a command line argument for amm starts with `'-'`, the argument will be set to this macro.");
    case ML.link_flag:
        return _("specify link flags for dmd When a command line argument for amm starts with `'-L'`, the argument will be set to this macro.");
    case ML.target:
        return _("specify the target file name of your project. On Windows, when a file that has `'.exe'` or `'.dll'` as its extension is passed as a command line argument for amm, the file name will be set to this macro.");
    case ML.dependencies:
        return _("Amm will set this value.");
    case ML.to_compile:
        return _("Amm will set this value.");
    case ML.to_link:
        return _("Amm will set this value.");
    case ML.rc_file:
        return _("On Windows, when a file that has `'.rc'` as its extension is passed as a command line argument for amm, the file name will be set to this macro.");
    case ML.def:
        return _("On Windows, when a file that has `'.def'` as its extension is passed as a command line argument for amm, the file name will be set to this macro.");
    case ML.ddoc:
        return _("On Windows, when a file that has `'.ddoc'` as its extension is passed as a command line argument for amm, the file name will be set to this macro.");
    case ML.dd:
        return _("specify the target directory of DDOC.");
    case ML.libs:
        return _("specify libraries names to link. Amm will gather names form the directory specified by the macro named `'lib'`.");
    case ML.imp:
        return _("specify the directory that contains the files to be imported by your project. The default value is `'import'`.");
    case ML.lib:
        return _("specify the directory that contains the file to be linked by your project. The default value is `'lib'`.");
    case ML.i:
        return _("Amm will set this value. this is same as `-I` option for dmd.");
    case ML.is_dll:
        return _("specify whether the target of your project is dynamic link library.");
    case ML.is_lib:
        return _("specify whether the target of your project is static link library.");
    case ML.verbose:
        return _("controls the verboseness of amm.");
    case ML.q:
        return _("controls the verboseness of amm.");
    case ML.footer:
        return _("specify the 'footer mark' of the Makefile. Amm will overwrite the Makefile. but, the contents after this mark will remain.");
    case ML.style_file:
        return _("specify the setting file name. The default value is `'make-style.xml'`.");
    case ML.v:
        return _("specify the description about your project.");
    case ML.authors:
        return _("specify the description about your project.");
    case ML.license:
        return _("specify the description about your project.");
    case ML.date:
        return _("Amm will set this value as today.");
    case ML.remake_command:
        return _("The command line arguments that invoked amm is set to the value.");
    case ML.src:
        return _("Amm set command line argument that starts with '-I' to this value. This value is used to decide that the root directory of source files to be compiled.");
    case ML.is_vclinker:
        return _("If true, dmd will invoke the linker of Microsoft.");
    case ML.dll_ext:
        return _("the extension of a Dynamic Linked Library. when a file with this extension is in the arguments, the file will be regarded as TARGET, and the macro 'IS_DLL' is defined.");
    case ML.mak_ext:
        return _("the extension of Makefile. when a file with this extension is in the arguments, the file will be regarded as Makefile.");
    case ML.src_ext:
        return _("The extension of a source file. When a file with this extension is in the arguments, the file will be regarded the root file of the project. and the file will be set to the value of the macro 'ROOT'. When the value of macro 'TARGET' is undefined, the value of the macro will be set as 'ROOT' + 'EXE_EXT'.");
    case ML.rc_ext:
        return _("The extension of a resource file. When a file with this extension is in the arguments, the file will be set to the value of the macro 'RC'. Windows only.");
    case ML.rc:
        return _("Resource files are set to this value. Windows only.");
    case ML.def_ext:
        return _("the extension of a module definition file of D. when a file with this extension is in the arguments, the file will be regarded as module definition file.");
    case ML.ddoc_ext:
        return _(" The extension of a file for ddoc. when a file with this extension is in the arguments, the file will be regarded as for ddoc.");
    case ML.xml_ext:
        return _("the extension of STYLE_FILE. when a file with this extension is in the arguments, the file will be regarded STYLE_FILE.");
    case ML.style:
        return _("STYLE_FILE controls the output. when a file with '.xml' extension is in the arguments, the file will be regarded as STYLE_FILE.");

    default:
        return _("no help message about %s", ml);
    }
    assert (0);
}


//
void logout_macros(Macros macros)
{
    import std.algorithm: sort;
    import sworks.base.strutil;
    import std.array: array;

    if (Output.MODE.VERBOSE <= Output.mode)
    {
        "---------- current macros".logln;
        auto keys = macros.keys.sort.array;
        auto tabs = new string[2][keys.length];
        foreach (size_t i, key; keys)
        {
            tabs[i][0] = key;
            tabs[i][1] = macros[key];
        }
        tabs.tabular("name", "value", -1, "=").logln;

        // foreach (key; macros.keys.sort)
        //     key.logln(" = ", macros[key]);
        "----------".logln;
    }
}

//
void show_help(string about, Getopt.Option[] opts, Macros macros)
{
    import std.format: format;
    import std.string: toLower;
    import sworks.base.strutil: tabular;

    alias ML = PredefinedMacrosList;

    header.outln;
    description.outln;
    outln;
    switch (about.toLower)
    {
    case "macro":
        _("Predefined macros are bellows.").outln;

        string[2][__traits(allMembers, ML).length] buf;
        foreach (i, one; __traits(allMembers, ML))
        {
            buf[i][0] = one;
            buf[i][1] = one.getHelpAboutMacro;
        }
        buf.tabular(_("name"), _("description"), 80).outln;

        break;
    default:
        how_to_use.outln;
        outln;
        Getopt.prettyDescriptor(opts, 80).outln;
        outln;
        _("To show more details, invoke with --help TOPICS.").outln;
        _("Available TOPICS are bellows.").outln;
        ("--help macro").outln;
        break;
    }
}

//
void output_readme()
{
    // "# AMM".outln;
    // outln;
    // Lang("## Description", "## 説明").outln;
    // header.outln;
    // description.outln;
    // outln;

    // Lang("## How to use", "## 実行方法").outln;
    // how_to_use.outln;
    // summary_of_commandline_options.outln;
    // outln;

    // Lang("## Command line arguments", "## コマンドライン引数").outln;
    // foreach (line; about_command_line_arguments)
    //     line.outln;
    // outln;

    // output_help_about_macro;
}

template NamedEnum(ARGS...)
{
    static if (0 < ARGS.length)
    {
        mixin("enum " ~ ARGS[0] ~ " = \"" ~ ARGS[0] ~ "\";");
        mixin NamedEnum!(ARGS[1..$]);
    }
}
