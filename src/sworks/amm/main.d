/**
 * Version:      0.160(dmd2.060)
 * Date:         2012-Oct-09 22:25:03
 * Authors:      KUMA
 * License:      CC0
 */

module sworks.amm.main;
import std.file, std.string, std.exception, std.conv;
import sworks.compo.util.output;
import sworks.compo.stylexml.macros;
import sworks.compo.stylexml.parser;
import sworks.amm.default_data;
import sworks.amm.args_data;
import sworks.amm.ready_data;
import sworks.amm.deps_data;
debug import std.stdio : writeln;

string header =
"Automatic Makefile Maker v0.160(dmd2.060)
";

// コマンドラインに表示するヘルプメッセージ
string help= q"HELP
** Usage
$>amm [target.exe] [make-style.xml] [option for dmd] [option] rootfile.d

** options
h help ?           : print this help.
macro_name         : define the 'macro_name' as macro.
macro_name=value   : define the 'macro_name' to be 'value'.
makefile=Makefile  : specify Makefile's name.
root=path          : add source file's root path.
                     this option also adds dmd's compile option -Ipath
                     default:
                     if 'src' directory is there, the root is set to 'src'.
                     else the root is set to current directory.
vwrite=v           : specify the version of the project.
                     this is the option for vwrite.exe.

**
if 'import' and 'src' directories are there, -Iimport;src is added to compile flags.
amm doesn't support the filename that contains ' '(space).
HELP";

struct MACROKEY
{
	enum BRACKET = "bracket";
	enum ENVIRONMENT_ID = "env";
	enum EXE_EXT = "exe_ext";
	enum OBJ_EXT = "obj_ext";
	enum LIB_EXT = "lib_ext";
	enum GENERATE_DEPS = "gen_deps_command";
	enum DEPS_FILE = "deps_file";
	enum MAKEFILE = "makefile";
	enum ROOT_FILE = "root_file";
	enum COMPILE_FLAG = "compile_flag";
	enum LINK_FLAG = "link_flag";
	enum TARGET = "target";
	enum DEPENDENCE = "dependencies";
	enum TO_COMPILE = "to_compile";
	enum TO_LINK = "to_link";
	enum RC_FILE = "rc_file";
	enum RES_FILE = "res_file";
	enum DEF_FILE = "def_file";
	enum DDOC_FILE = "ddoc_file";
	enum DDOC_DIRECTORY = "ddoc_directory";
	enum EXT_LIB = "ext_lib";
	enum INSTALL_DIRECTORY = "install_directory";
	enum PROJECT_DIRECTORY = "project";
	enum SRC_DIRECTORY = "root";
	enum IMPORT_DIRECTORY = "imp_root";
	enum EXT_LIB_DIRECTORY = "lib_root";
	enum DMD_DIRECTORY = "i";

	enum TARGET_IS_DLL = "dll";
	enum TARGET_IS_LIB = "lib";

	enum VERBOSE = "verbose";
	enum QUIET = "quiet";

	enum FOOTER = "footer";
	enum STYLE_FILE = "style_file";
	enum REMAKE_COMMAND = "remake_command";
	enum VWRITE = "vwrite";
}

struct DEFAULT_VALUE
{
	version( Windows )
	{
		enum BRACKET = "rn";
		enum EXE_EXT = ".exe";
		enum OBJ_EXT = ".obj";
		enum LIB_EXT = ".lib";
	}
	version( linux )
	{
		enum BRACKET = "n";
		enum EXE_EXT = "";
		enum OBJ_EXT = ".o";
		enum LIB_EXT = ".a";
	}

	enum GENERATE_DEPS = "dmd -c -op -o- -deps=tempdeps -debug";
	enum DEPS_FILE = "tempdeps"; // <----------^^^^^^^^ 同じにしておく。
	enum MAKEFILE = "Makefile";
	enum INSTALL_DIRECTORY = ".";
	enum PROJECT_DIRECTORY = ".";
	enum SRC_DIRECTORY = "src";
	enum IMPORT_DIRECTORY = "import";
	enum EXT_LIB_DIRECTORY = "lib";
	enum DDOC_DIRECTORY = "doc";
	enum STYLE_FILE = "make-style.xml";
	enum FOOTER = "## generated by amm.";
}


void main(string[] args)
{
	Output output = new Output;

	// 引数がない場合はヘルプを出力して終了
	if( args.length <= 1 ){ output.ln( header, help ); return; }
	auto tempargs = args;
	args.length = 0;
	debug{ output.mode = Output.MODE.VERBOSE; }
	// ヘルプが必要か、と、出力の冗長性に関しては先に調べておく。
	foreach( one ; tempargs )
	{
		// ヘルプが要求されている場合
		if     ( ("h" == one) || ("help" == one) || ("?" == one) || ("-h" == one) || ("-help" == one)
					 || ("--help" == one) || "/?" == one )
		{
			output.ln( header, help );
			return;
		}
		// 出力の冗長性の制御
		else if( "verbose" == one || "-verbose" == one || "--verbose" == one ) output.mode = Output.MODE.VERBOSE;
		else if( "quiet" == one || "-quiet" == one || "--quiet" == one ) output.mode = Output.MODE.QUIET;
		else args ~= one;
	}

	StyleParser parser;
	Macros macros = new Macros;
	set_default_data!(MACROKEY, DEFAULT_VALUE)( macros );
	set_args_data!MACROKEY( macros, args, output );

	output.logln(header);

	auto str = to!string( read( macros[MACROKEY.STYLE_FILE] ) );
	output.logln("success to open ", macros[MACROKEY.STYLE_FILE] );
	parser = new StyleParser( str, macros );
	output.logln( "parser is ready" );

	// -style.xml ファイルのヘッダだけは読み込んでおく。
	parser.parseHead();
	output.logln( "<head> is parsed successfully" );
	ready_data!MACROKEY( macros, output );
	output.logln( "macros are ready" );
	set_deps_data!MACROKEY(macros, output);
	output.logln( "dependencies are whole resolved." );
	// 準備完了
	// -style.xml ファイルのボディを処理する。
	output.logln("parse start.");
	auto makefile_cont = parser.parseBody();
	output.logln("parse success.");

	enforce( 0 < makefile_cont.length, "failed to generate Makefile with " ~ macros[MACROKEY.STYLE_FILE] );

	// Makefile が既存で、footer が見つかった場合、それ以降は残す。
	if( exists(macros[MACROKEY.MAKEFILE]) && macros.have(MACROKEY.FOOTER) )
	{
		output.logln("old makefile is detected.");
		auto old_makefile_cont = to!string(read(macros[MACROKEY.MAKEFILE]));
		int i = old_makefile_cont.lastIndexOf(macros[MACROKEY.FOOTER]);
		if( 0 < i )
		{
			string post_footer = old_makefile_cont[ i+macros[MACROKEY.FOOTER].length .. $];
			if( 0 < post_footer.length )
			{
				output.logln("post-footers are detected.");
				makefile_cont ~= post_footer;
			}
		}
	}

	// Makefile を出力。
	write( macros[MACROKEY.MAKEFILE], makefile_cont );
	output.logln("output the makefile, success.");

	output.logln("complete.");
}

